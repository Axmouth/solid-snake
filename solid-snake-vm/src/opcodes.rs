use num_enum::TryFromPrimitive;
use solid_snake_vm_macros::DecodedInstructionEnum;
use strum_macros::EnumString;

use crate::executor::ext::VmExecutionError;
use crate::executor::interpreted::implimentation::{
    ExecutableInstruction, ExecutableInstructionFn,
};
use crate::executor::interpreted::{
    opcode_decoder::{
        InstructionArgs, InstructionArgsFromStr, OpcodeHandler, ParseHandler, VmParseError,
    },
    opcode_impl::all::*,
};
use crate::{RegisterType, VmInterpretedExecutor};
use crate::docs::InstructionDocsEntry;

// TODO: autogenerate docs?
#[derive(Debug, DecodedInstructionEnum, TryFromPrimitive, EnumString, PartialEq, Clone, Copy)]
#[repr(u16)]
pub enum OpCode {
    // TODO: Jump indirect?
    // Jumps use u64 as target address, conditions are u8
    JumpIfFalse = 1,
    JumpIf = 2,
    Jump = 3,

    // TODO: correct taking into account how memory is handled as registers, never raw pointers. Registers of heap pieces with offset in them
    // Load instructions have variants for each type
    // LoadIndirect: Load a value from memory pointed to by a register (i.e., indirect addressing).
    // LoadImmediate: Load a constant (immediate value) directly into a register.
    // LoadFromImmediate: The immediate encodes a memory address, and the instruction loads from that address.
    LoadIndirectU8 = 20,
    LoadIndirectU16 = 21,
    LoadIndirectU32 = 22,
    LoadIndirectU64 = 23,
    LoadIndirectI8 = 24,
    LoadIndirectI16 = 25,
    LoadIndirectI32 = 26,
    LoadIndirectI64 = 27,
    LoadIndirectF32 = 28,
    LoadIndirectF64 = 29,

    LoadIndirectWithOffsetU8 = 30,
    LoadIndirectWithOffsetU16 = 31,
    LoadIndirectWithOffsetU32 = 32,
    LoadIndirectWithOffsetU64 = 33,
    LoadIndirectWithOffsetI8 = 34,
    LoadIndirectWithOffsetI16 = 35,
    LoadIndirectWithOffsetI32 = 36,
    LoadIndirectWithOffsetI64 = 37,
    LoadIndirectWithOffsetF32 = 38,
    LoadIndirectWithOffsetF64 = 39,

    LoadImmediateU8 = 40,
    LoadImmediateU16 = 41,
    LoadImmediateU32 = 42,
    LoadImmediateU64 = 43,
    LoadImmediateI8 = 44,
    LoadImmediateI16 = 45,
    LoadImmediateI32 = 46,
    LoadImmediateI64 = 47,
    LoadImmediateF32 = 48,
    LoadImmediateF64 = 49,

    LoadFromImmediateU8 = 60,
    LoadFromImmediateU16 = 61,
    LoadFromImmediateU32 = 62,
    LoadFromImmediateU64 = 63,
    LoadFromImmediateI8 = 64,
    LoadFromImmediateI16 = 65,
    LoadFromImmediateI32 = 66,
    LoadFromImmediateI64 = 67,
    LoadFromImmediateF32 = 68,
    LoadFromImmediateF64 = 69,

    // LoadFromImmediateWithOffsetU8 = 70,
    // LoadFromImmediateWithOffsetU16 = 71,
    // LoadFromImmediateWithOffsetU32 = 72,
    // LoadFromImmediateWithOffsetU64 = 73,
    // LoadFromImmediateWithOffsetI8 = 74,
    // LoadFromImmediateWithOffsetI16 = 75,
    // LoadFromImmediateWithOffsetI32 = 76,
    // LoadFromImmediateWithOffsetI64 = 77,
    // LoadFromImmediateWithOffsetF32 = 78,
    // LoadFromImmediateWithOffsetF64 = 79,

    // Store instructions have variants for each type
    // StoreIndirect: Store a value into memory at an address held in another register.
    // StoreImmediate: Store a constant value into a register (could be redundant with LoadImmediate, but possibly for symmetry).
    // StoreFromImmediate: Store to a constant address from a register â€” i.e., store value into a hardcoded address.
    // StoreIndirectU8 = 80,
    // StoreIndirectU16 = 81,
    // StoreIndirectU32 = 82,
    // StoreIndirectU64 = 83,
    // StoreIndirectI8 = 84,
    // StoreIndirectI16 = 85,
    // StoreIndirectI32 = 86,
    // StoreIndirectI64 = 87,
    // StoreIndirectF32 = 88,
    // StoreIndirectF64 = 89,
    StoreIndirectWithOffsetU8 = 90,
    StoreIndirectWithOffsetU16 = 91,
    StoreIndirectWithOffsetU32 = 92,
    StoreIndirectWithOffsetU64 = 93,
    StoreIndirectWithOffsetI8 = 94,
    StoreIndirectWithOffsetI16 = 95,
    StoreIndirectWithOffsetI32 = 96,
    StoreIndirectWithOffsetI64 = 97,
    StoreIndirectWithOffsetF32 = 98,
    StoreIndirectWithOffsetF64 = 99,

    // StoreImmediateU8 = 100,
    // StoreImmediateU16 = 101,
    // StoreImmediateU32 = 102,
    // StoreImmediateU64 = 103,
    // StoreImmediateI8 = 104,
    // StoreImmediateI16 = 105,
    // StoreImmediateI32 = 106,
    // StoreImmediateI64 = 107,
    // StoreImmediateF32 = 108,
    // StoreImmediateF64 = 109,

    // StoreFromImmediateU8 = 120,
    // StoreFromImmediateU16 = 121,
    // StoreFromImmediateU32 = 122,
    // StoreFromImmediateU64 = 123,
    // StoreFromImmediateI8 = 124,
    // StoreFromImmediateI16 = 125,
    // StoreFromImmediateI32 = 126,
    // StoreFromImmediateI64 = 127,
    // StoreFromImmediateF32 = 128,
    // StoreFromImmediateF64 = 129,
    StoreFromImmediateWithOffsetU8 = 130,
    StoreFromImmediateWithOffsetU16 = 131,
    StoreFromImmediateWithOffsetU32 = 132,
    StoreFromImmediateWithOffsetU64 = 133,
    StoreFromImmediateWithOffsetI8 = 134,
    StoreFromImmediateWithOffsetI16 = 135,
    StoreFromImmediateWithOffsetI32 = 136,
    StoreFromImmediateWithOffsetI64 = 137,
    StoreFromImmediateWithOffsetF32 = 138,
    StoreFromImmediateWithOffsetF64 = 139,

    // Logical operations are applied only to u64 operands used as booleans
    LogicalAnd = 150,
    LogicalOr = 151,
    LogicalNot = 152,
    LogicalXor = 153,

    // Math instructions have variants for each type
    AddU8 = 170,
    AddU16 = 171,
    AddU32 = 172,
    AddU64 = 173,
    AddI8 = 174,
    AddI16 = 175,
    AddI32 = 176,
    AddI64 = 177,
    AddF32 = 178,
    AddF64 = 179,

    SubtractU8 = 200,
    SubtractU16 = 201,
    SubtractU32 = 202,
    SubtractU64 = 203,
    SubtractI8 = 204,
    SubtractI16 = 205,
    SubtractI32 = 206,
    SubtractI64 = 207,
    SubtractF32 = 208,
    SubtractF64 = 209,

    MultiplyU8 = 230,
    MultiplyU16 = 231,
    MultiplyU32 = 232,
    MultiplyU64 = 233,
    MultiplyI8 = 234,
    MultiplyI16 = 235,
    MultiplyI32 = 236,
    MultiplyI64 = 237,
    MultiplyF32 = 238,
    MultiplyF64 = 239,

    DivideU8 = 260,
    DivideU16 = 261,
    DivideU32 = 262,
    DivideU64 = 263,
    DivideI8 = 264,
    DivideI16 = 265,
    DivideI32 = 266,
    DivideI64 = 267,
    DivideF32 = 268,
    DivideF64 = 269,

    ModuloU8 = 290,
    ModuloU16 = 291,
    ModuloU32 = 292,
    ModuloU64 = 293,
    ModuloI8 = 294,
    ModuloI16 = 295,
    ModuloI32 = 296,
    ModuloI64 = 297,
    ModuloF32 = 298,
    ModuloF64 = 299,

    // Equality instructions have variants for each type
    EqualU8 = 350,
    EqualU16 = 351,
    EqualU32 = 352,
    EqualU64 = 353,
    EqualI8 = 354,
    EqualI16 = 355,
    EqualI32 = 356,
    EqualI64 = 357,
    EqualF32 = 358,
    EqualF64 = 359,

    NotEqualU8 = 380,
    NotEqualU16 = 381,
    NotEqualU32 = 382,
    NotEqualU64 = 383,
    NotEqualI8 = 384,
    NotEqualI16 = 385,
    NotEqualI32 = 386,
    NotEqualI64 = 387,
    NotEqualF32 = 388,
    NotEqualF64 = 389,
    LessThanU8 = 410,
    LessThanU16 = 411,
    LessThanU32 = 412,
    LessThanU64 = 413,
    LessThanI8 = 414,
    LessThanI16 = 415,
    LessThanI32 = 416,
    LessThanI64 = 417,
    LessThanF32 = 418,
    LessThanF64 = 419,

    LessThanOrEqualU8 = 440,
    LessThanOrEqualU16 = 441,
    LessThanOrEqualU32 = 442,
    LessThanOrEqualU64 = 443,
    LessThanOrEqualI8 = 444,
    LessThanOrEqualI16 = 445,
    LessThanOrEqualI32 = 446,
    LessThanOrEqualI64 = 447,
    LessThanOrEqualF32 = 448,
    LessThanOrEqualF64 = 449,

    GreaterThanU8 = 470,
    GreaterThanU16 = 471,
    GreaterThanU32 = 472,
    GreaterThanU64 = 473,
    GreaterThanI8 = 474,
    GreaterThanI16 = 475,
    GreaterThanI32 = 476,
    GreaterThanI64 = 477,
    GreaterThanF32 = 478,
    GreaterThanF64 = 479,

    GreaterThanOrEqualU8 = 500,
    GreaterThanOrEqualU16 = 501,
    GreaterThanOrEqualU32 = 502,
    GreaterThanOrEqualU64 = 503,
    GreaterThanOrEqualI8 = 504,
    GreaterThanOrEqualI16 = 505,
    GreaterThanOrEqualI32 = 506,
    GreaterThanOrEqualI64 = 507,
    GreaterThanOrEqualF32 = 508,
    GreaterThanOrEqualF64 = 509,

    // Atomic instructions have variants for each type
    // AtomicSwapU8 = 530,
    // AtomicSwapU16 = 531,
    // AtomicSwapU32 = 532,
    // AtomicSwapU64 = 533,
    // AtomicSwapI8 = 534,
    // AtomicSwapI16 = 535,
    // AtomicSwapI32 = 536,
    // AtomicSwapI64 = 537,

    // CompareAndSwapU8 = 560,
    // CompareAndSwapU16 = 561,
    // CompareAndSwapU32 = 562,
    // CompareAndSwapU64 = 563,
    // CompareAndSwapI8 = 564,
    // CompareAndSwapI16 = 565,
    // CompareAndSwapI32 = 566,
    // CompareAndSwapI64 = 567,

    // Call Moves the program counter to target u64 address
    CallFunction = 600,

    // Returns to caller address or stack pointer
    Return = 601,

    // Allocates a piece of memory of u64 size as given by a source register to a target register
    Allocate = 602,

    // Deallocates memory pointed to by target register
    Deallocate = 603,

    // Copies data from one register/memory location to another
    Memcpy = 604,

    // Sets a range of memory locations to a specific value, often used in initializing
    MemSet = 605,

    // Just Stop, with a return code
    Halt = 606,

    // Must have pretty much all plausible combinations of types, for source and target
    // ConvertU8ToU16 = 700,
    // ConvertU8ToU32 = 701,
    // ConvertU8ToU64 = 702,
    // ConvertU8ToI8 = 703,
    // ConvertU8ToI16 = 704,
    // ConvertU8ToI32 = 705,
    // ConvertU8ToI64 = 706,
    // ConvertU8ToF32 = 707,
    // ConvertU8ToF64 = 708,

    // ConvertU16ToU8 = 710,
    // ConvertU16ToU32 = 711,
    // ConvertU16ToU64 = 712,
    // ConvertU16ToI8 = 713,
    // ConvertU16ToI16 = 714,
    // ConvertU16ToI32 = 715,
    // ConvertU16ToI64 = 716,
    // ConvertU16ToF32 = 717,
    // ConvertU16ToF64 = 718,

    // ConvertU32ToU8 = 720,
    // ConvertU32ToU16 = 721,
    // ConvertU32ToU64 = 722,
    // ConvertU32ToI8 = 723,
    // ConvertU32ToI16 = 724,
    // ConvertU32ToI32 = 725,
    // ConvertU32ToI64 = 726,
    // ConvertU32ToF32 = 727,
    // ConvertU32ToF64 = 728,

    // ConvertU64ToU8 = 730,
    // ConvertU64ToU16 = 731,
    // ConvertU64ToU32 = 732,
    // ConvertU64ToI8 = 733,
    // ConvertU64ToI16 = 734,
    // ConvertU64ToI32 = 735,
    // ConvertU64ToI64 = 736,
    // ConvertU64ToF32 = 737,
    // ConvertU64ToF64 = 738,

    // ConvertI8ToU8 = 740,
    // ConvertI8ToU16 = 741,
    // ConvertI8ToU32 = 742,
    // ConvertI8ToU64 = 743,
    // ConvertI8ToI16 = 744,
    // ConvertI8ToI32 = 745,
    // ConvertI8ToI64 = 746,
    // ConvertI8ToF32 = 747,
    // ConvertI8ToF64 = 748,

    // ConvertI16ToU8 = 750,
    // ConvertI16ToU16 = 751,
    // ConvertI16ToU32 = 752,
    // ConvertI16ToU64 = 753,
    // ConvertI16ToI8 = 754,
    // ConvertI16ToI32 = 755,
    // ConvertI16ToI64 = 756,
    // ConvertI16ToF32 = 757,
    // ConvertI16ToF64 = 758,

    // ConvertI32ToU8 = 760,
    // ConvertI32ToU16 = 761,
    // ConvertI32ToU32 = 762,
    // ConvertI32ToU64 = 763,
    // ConvertI32ToI8 = 764,
    // ConvertI32ToI16 = 765,
    // ConvertI32ToI64 = 766,
    // ConvertI32ToF32 = 767,
    // ConvertI32ToF64 = 768,

    // ConvertI64ToU8 = 770,
    // ConvertI64ToU16 = 771,
    // ConvertI64ToU32 = 772,
    // ConvertI64ToU64 = 773,
    // ConvertI64ToI8 = 774,
    // ConvertI64ToI16 = 775,
    // ConvertI64ToI32 = 776,
    // ConvertI64ToF32 = 777,
    // ConvertI64ToF64 = 778,

    // ConvertF32ToU8 = 780,
    // ConvertF32ToU16 = 781,
    // ConvertF32ToU32 = 782,
    // ConvertF32ToU64 = 783,
    // ConvertF32ToI8 = 784,
    // ConvertF32ToI16 = 785,
    // ConvertF32ToI32 = 786,
    // ConvertF32ToI64 = 787,
    // ConvertF32ToF64 = 788,

    // ConvertF64ToU8 = 790,
    // ConvertF64ToU16 = 791,
    // ConvertF64ToU32 = 792,
    // ConvertF64ToU64 = 793,
    // ConvertF64ToI8 = 794,
    // ConvertF64ToI16 = 795,
    // ConvertF64ToI32 = 796,
    // ConvertF64ToI64 = 797,
    // ConvertF64ToF32 = 798,
    MoveU8 = 821,
    MoveU16 = 822,
    MoveU32 = 823,
    MoveU64 = 824,
    MoveI8 = 825,
    MoveI16 = 826,
    MoveI32 = 827,
    MoveI64 = 828,
    MoveF32 = 829,
    MoveF64 = 830,

    IncrementU8 = 841,
    IncrementU16 = 842,
    IncrementU32 = 843,
    IncrementU64 = 844,
    IncrementI8 = 845,
    IncrementI16 = 846,
    IncrementI32 = 847,
    IncrementI64 = 848,
    IncrementF32 = 849,
    IncrementF64 = 850,

    DecrementU8 = 861,
    DecrementU16 = 862,
    DecrementU32 = 863,
    DecrementU64 = 864,
    DecrementI8 = 865,
    DecrementI16 = 866,
    DecrementI32 = 867,
    DecrementI64 = 868,
    DecrementF32 = 869,
    DecrementF64 = 870,

    BitwiseAndU8 = 900,
    BitwiseAndU16 = 901,
    BitwiseAndU32 = 902,
    BitwiseAndU64 = 903,
    BitwiseAndI8 = 904,
    BitwiseAndI16 = 905,
    BitwiseAndI32 = 906,
    BitwiseAndI64 = 907,

    BitwiseOrU8 = 910,
    BitwiseOrU16 = 911,
    BitwiseOrU32 = 912,
    BitwiseOrU64 = 913,
    BitwiseOrI8 = 914,
    BitwiseOrI16 = 915,
    BitwiseOrI32 = 916,
    BitwiseOrI64 = 917,

    BitwiseXorU8 = 920,
    BitwiseXorU16 = 921,
    BitwiseXorU32 = 922,
    BitwiseXorU64 = 923,
    BitwiseXorI8 = 924,
    BitwiseXorI16 = 925,
    BitwiseXorI32 = 926,
    BitwiseXorI64 = 927,

    BitwiseNotU8 = 930,
    BitwiseNotU16 = 931,
    BitwiseNotU32 = 932,
    BitwiseNotU64 = 933,
    BitwiseNotI8 = 934,
    BitwiseNotI16 = 935,
    BitwiseNotI32 = 936,
    BitwiseNotI64 = 937,

    ShiftLeftU8 = 940,
    ShiftLeftU16 = 941,
    ShiftLeftU32 = 942,
    ShiftLeftU64 = 943,
    ShiftLeftI8 = 944,
    ShiftLeftI16 = 945,
    ShiftLeftI32 = 946,
    ShiftLeftI64 = 947,

    ShiftRightU8 = 950,
    ShiftRightU16 = 951,
    ShiftRightU32 = 952,
    ShiftRightU64 = 953,
    ShiftRightI8 = 954,
    ShiftRightI16 = 955,
    ShiftRightI32 = 956,
    ShiftRightI64 = 957,

    // System
    // Print takes a pointer register, an offset, and a length prints the contents as a string
    Print = 1000,

    // Followed by u64 amount of bytes. Stores them to memory pointed to by target register
    // StoreArrayImmediate = 1020,
    StoreConstantArray = 1030,

    // A way to check if errors happened with specific codes, versions for using register and constant
    // ErrorFlagEqualIndirect = 1100,
    // ErrorFlagEqualImmediate = 1101,
    // Jumps to given code address if error register is set. Does not clear the register, versions for using register and constant
    // JumpIfErrorIndirect = 1120,
    // JumpIfErrorImmediate = 1121,
    DebugPrintU8 = 2000,
    DebugPrintU16 = 2001,
    DebugPrintU32 = 2002,
    DebugPrintU64 = 2003,
    DebugPrintI8 = 20004,
    DebugPrintI16 = 2005,
    DebugPrintI32 = 2006,
    DebugPrintI64 = 2007,
    DebugPrintF32 = 2008,
    DebugPrintF64 = 2009,
    DebugPrintRaw = 2010,
    // TODO : import for bytecode modules
    // TODO : import for ffi extensions
    // TODO : threading (fork, join?)
}

impl OpCode {
    pub fn get_docs() -> Vec<crate::docs::InstructionDocsEntry> {
        Self::variant_iter().map(Self::get_doc).collect::<Vec<_>>()
    }
}